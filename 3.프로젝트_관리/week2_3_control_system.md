# 2-3주차: 핵심 조작 시스템 상세 계획 (의존성 해결)

## 📅 주차 개요
- **기간**: 2-3주차 (14일)
- **목표**: 워크래프트 스타일 정밀 조작 시스템 완성
- **핵심 성과물**: 생존자 선택, 명령, 카메라 제어가 완전히 작동하는 프로토타입
- **의존성 해결**: A 우선 작업 → 더미 데이터 활용 → 단계적 실제 데이터 연동

## ⚠️ 의존성 분석 및 해결 방안

### **문제점 파악**
```
🔴 심각한 의존성:
- C의 선택 시스템 ← A의 BP_Survivor 클래스 필요
- B의 UI 데이터 바인딩 ← A의 GameState 필요
- 통합 테스트 ← 모든 기본 클래스 완성 필요

🟡 중간 의존성:
- B의 생존자 정보 UI ← C의 선택 이벤트 필요
- 전체 시스템 파이프라인 ← 모든 개별 시스템 완성 필요
```

### **해결 전략**
```
1단계: A 우선 작업 (2주차 1-2일)
- A가 기반 클래스들을 먼저 완성
- B, C는 더미 데이터로 병렬 작업 준비

2단계: 병렬 작업 (2주차 3-4일)
- A: 카메라 시스템
- B: 더미 데이터 기반 UI
- C: 더미 선택 시스템

3단계: 단계적 통합 (3주차)
- 더미 → 실제 데이터 교체
- 시스템 간 연동 완성
```

## 👥 팀별 상세 작업 계획

### 🎮 개발자 A (게임플레이 담당) - 28시간

#### **2주차 (14시간): 기반 클래스 우선 + 카메라 시스템**
```
Day 1-2: 핵심 기반 클래스 (7시간) - 🚨 최우선 작업
□ BP_Survivor 기본 구조 생성
  - Pawn 클래스 상속
  - 기본 컴포넌트 (Capsule, Mesh, Movement)
  - 필수 변수 (ID, Name, IsSelected, CurrentState)
  - 더미 함수 (SelectSurvivor, MoveTo, SetState)

□ GameState/GameMode 기본 구조
  - BP_SurvivalGameState: 생존자 배열, 자원 변수
  - BP_SurvivalGameMode: 기본 게임 규칙
  - 더미 데이터로 초기화 (자원 50/100/30/100/100)
  - UI 바인딩용 함수들 생성

□ 팀 공유 작업 (화요일 오전)
  - Git 푸시 및 사용법 문서화
  - 팀 회의로 인터페이스 설명 (2시간)

Day 3-4: 탑뷰 카메라 시스템 (7시간)
□ Spring Arm + Camera 컴포넌트 설정
  - Spring Arm Length: 1500-3000 범위
  - Camera Angle: -75도 (탑뷰)

□ WASD 카메라 이동 (Enhanced Input)
  - 이동 속도: 1000 unit/sec
  - 월드 경계 제한 (X,Y: ±5000)
  - 부드러운 보간 (Interp Speed: 5.0)

□ 마우스 휠 줌 시스템
  - 줌 범위: 800-4000 unit
  - 줌 중심점: 마우스 커서 위치
  - Timeline 활용 부드러운 애니메이션
```

#### **3주차 (14시간): 이동 시스템 및 UI 연동**
```
Day 1-2: 생존자 이동 및 애니메이션 (7시간)
□ NavMesh 기반 이동 시스템
  - AI Move To 노드 활용
  - 목표 지점 설정 및 이동 완료 이벤트
  - 이동 중 상태 관리

□ 기본 애니메이션 연동
  - Animation Blueprint: ABP_Survivor
  - Idle, Walking 상태 블렌딩
  - 이동 속도에 따른 애니메이션 조절

Day 3-4: 카메라-UI 연동 완성 (7시간)
□ 미니맵 클릭 → 카메라 이동
  - UI 좌표 → 월드 좌표 변환
  - 부드러운 카메라 이동 (2초 애니메이션)

□ 카메라 정보를 UI에 전달
  - 현재 카메라 위치/줌 정보 제공
  - UI 업데이트 이벤트 연동

□ 전체 시스템 통합 테스트 지원
```

### 🖼️ 개발자 B (UI/데이터 담당) - 56시간

#### **2주차 (28시간): 더미 데이터 기반 UI 구현**
```
Day 1-2: 인터페이스 설계 + 더미 UI (14시간)
□ 팀 인터페이스 설계 회의 참여 (2시간)
  - A의 클래스 구조 이해
  - 데이터 바인딩 방식 결정
  - 더미 → 실제 데이터 전환 계획

□ WBP_MainHUD 기본 구조 (12시간)
  - 화면 레이아웃 (1920x1080 기준)
  - WBP_TopBar (자원 표시 영역)
  - WBP_BottomPanel (선택 정보 + 메뉴)
  - WBP_LeftSidebar (생존자 목록)
  - 더미 데이터로 UI 표시 테스트

Day 3-4: 자원 표시 시스템 (14시간)
□ WBP_ResourceDisplay 컴포넌트
  - 아이콘 + 텍스트 + 진행바 (120x60px)
  - 상태별 색상 (풍족/보통/부족/위험)
  - 5개 자원별 아이콘 적용

□ 더미 데이터 기반 테스트
  - 하드코딩된 값으로 UI 동작 검증
  - 상태 변화 애니메이션 테스트
  - 부족시 깜빡임 효과 구현
```

#### **3주차 (28시간): 실제 데이터 연동 + 생존자 UI**
```
Day 1-2: 실제 GameState 연동 (14시간)
□ A의 GameState와 데이터 바인딩
  - 더미 데이터 → 실제 데이터 교체
  - Widget Blueprint 바인딩 설정
  - 실시간 업데이트 확인

□ 자원 시스템 실제 연동
  - GameState 자원 변수와 바인딩
  - 자원 변경시 UI 즉시 업데이트
  - 메모리 누수 방지 (바인딩 해제)

Day 3-4: 생존자 정보 UI + 알림 시스템 (14시간)
□ WBP_SurvivorInfo 위젯 (C의 선택 이벤트 연동)
  - 선택된 생존자 정보 표시 (350x120px)
  - 체력/피로도 바 실시간 업데이트
  - 다중 선택시 그룹 정보 표시

□ 알림 시스템 (WBP_Notification)
  - 우측 상단 알림 영역
  - 타입별 색상 구분, 자동 사라짐
  - 클릭시 관련 위치로 카메라 이동
```

### 🤖 개발자 C (AI/전투 담당) - 56시간

#### **2주차 (28시간): 기본 AI + 더미 선택 시스템**
```
Day 1-2: AI 기본 구조 + 인터페이스 (14시간)
□ 팀 인터페이스 설계 회의 참여 (2시간)
  - A의 클래스와 연동할 AI 설계
  - 선택/명령 이벤트 구조 합의

□ AI Controller 기본 구조 (12시간)
  - BP_SurvivorAIController 생성
  - Behavior Tree, Blackboard 설정
  - 기본 상태 (Idle, Moving, Working) 정의
  - 더미 선택 시스템 (마우스 클릭 감지)

Day 3-4: NavMesh + 기본 이동 AI (14시간)
□ NavMesh 시스템 설정
  - NavMesh Bounds Volume 배치
  - Agent 설정 (Radius: 42, Height: 88)
  - NavLink Proxy로 연결점 설정

□ 기본 이동 AI 구현
  - AI Move To 활용
  - 경로 탐색 실패시 대안 처리
  - 이동 완료 이벤트 처리
  - 더미 이동 명령 처리
```

#### **3주차 (28시간): 완전한 선택 + 명령 시스템**
```
Day 1-2: 실제 선택 시스템 (14시간)
□ A의 BP_Survivor 활용한 선택
  - 마우스 레이캐스팅으로 생존자 감지
  - 단일/다중 선택 구현
  - 선택 상태 시각화 (Outline 효과)
  - 선택 이벤트를 B(UI)에 전달

□ 드래그 박스 선택
  - 실시간 선택 박스 그리기
  - 박스 내부 생존자 검출
  - Shift, Ctrl 수정 키 조합

Day 3-4: 워크래프트 스타일 명령 시스템 (14시간)
□ 명령 키 입력 처리
  - A, M, G, S, H 키 매핑 (Enhanced Input)
  - 명령 모드 상태 관리
  - 커서 변경 및 시각적 피드백

□ 컨트롤 그룹 + 명령 대기열
  - Ctrl+1~9 그룹 저장/선택
  - Shift+명령으로 대기열 추가
  - 스마트 캐스트 vs 정밀 명령 구분
```

## 🔗 수정된 협업 일정

### **2주차 화요일: 긴급 팀 회의 (새로 추가)**
```
오전 2시간 회의:
□ A의 기반 클래스 구조 설명
□ 인터페이스 설계 및 연동 방법 합의
□ 더미 데이터 vs 실제 데이터 전환 계획
□ 각자 작업 주의사항 및 일정 조정

오후부터 병렬 작업 시작:
□ A: 카메라 시스템 개발
□ B: 더미 데이터로 UI 구현
□ C: 더미 선택 시스템 구현
```

### **2주차 목요일: 1차 통합 테스트**
```
통합 테스트 (4시간):
□ A의 생존자 클래스 + C의 선택 시스템 연동
□ A의 카메라 + B의 UI 기본 연결 테스트
□ 더미 데이터 기반 전체 시스템 검증
□ 발견된 문제점 공유 및 해결 방향 논의

주말 개별 보완 작업:
□ 1차 통합에서 발견된 문제 해결
□ 다음 주 실제 데이터 연동 준비
```

### **3주차 수요일: 2차 통합 테스트**
```
실제 데이터 연동 (전체 하루):
□ B: 더미 데이터 → 실제 GameState 연동
□ C: 더미 선택 → 실제 생존자 선택 연동
□ A: 카메라-UI 상호작용 완성
□ 전체 팀: 실시간 데이터 업데이트 테스트

성능 및 안정성 검증:
□ 다수 생존자 동시 선택/이동 테스트
□ UI 업데이트 지연시간 측정 (목표: 100ms 이내)
□ 메모리 누수 체크 및 최적화
```

### **3주차 금요일: 최종 통합 완성**
```
전체 시스템 파이프라인:
□ 카메라 → 선택 → UI → 명령 → AI 전체 흐름
□ 워크래프트 스타일 조작 완전 구현
□ 모든 단축키 및 명령 조합 테스트
□ 사용성 테스트 및 피드백 반영

다음 주차 연결 준비:
□ 자원 오브젝트 인식 기반 마련
□ 수집 명령(G키) 처리 인터페이스 준비
□ 인벤토리 시스템 연동점 확보
```

## ✅ 완료 기준

### **기술적 완료 기준**
```
필수 완료 항목:
□ WASD로 부드러운 카메라 이동 (1000 unit/sec)
□ 마우스 휠로 자연스러운 줌 (800-4000 unit 범위)
□ 미니맵 클릭으로 카메라 즉시 이동
□ 생존자 7명 개별 선택 가능 (좌클릭)
□ 드래그 박스로 다중 선택 (Shift, Ctrl 조합)
□ 컨트롤 그룹 설정 및 사용 (Ctrl+1~9, 1~9)
□ 워크래프트 스타일 명령 키 (A, M, G, S, H) 작동
□ 우클릭 스마트 캐스트 vs 정밀 명령 구분
□ Shift+명령으로 명령 대기열 생성
□ UI에 자원, 생존자 정보 실시간 표시

성능 요구사항:
□ 생존자 7명 동시 선택/이동시 30 FPS 이상
□ 카메라 이동시 끊김 없는 부드러운 움직임
□ UI 업데이트 지연시간 100ms 이내
```

### **협업 완료 기준 (새로 추가)**
```
의존성 해결 확인:
□ A의 기반 클래스를 B, C가 문제없이 사용
□ 더미 데이터에서 실제 데이터로 전환 완료
□ 모든 시스템이 실시간으로 연동 작동
□ Git 충돌 없이 팀 협업 원활히 진행

통합 품질 기준:
□ 2주차 목요일: 기본 연동 테스트 통과
□ 3주차 수요일: 실제 데이터 연동 테스트 통과
□ 3주차 금요일: 전체 시스템 완전 통합 달성
□ 각 단계별 성능 목표 달성
```

## 🎯 최종 데모 (3주차 금요일)

### **데모 시나리오**
```
1. 게임 시작 → 7명 생존자 화면에 표시
2. WASD로 카메라 이동하며 전체 맵 확인
3. 개별 생존자 클릭 선택 → UI에 정보 표시
4. 드래그로 여러 생존자 선택 → 그룹 정보 표시
5. 우클릭으로 그룹 이동 → 자연스러운 이동
6. Ctrl+1로 컨트롤 그룹 저장 → 1키로 재선택
7. A키+클릭으로 공격 명령 (명령 입력 확인)
8. Shift+우클릭으로 연속 이동 명령
9. 미니맵 클릭으로 카메라 즉시 이동
10. 전체 과정이 끊김 없이 자연스럽게 진행

성공 기준:
□ 모든 시나리오가 에러 없이 실행
□ 조작감이 상용 RTS 게임 수준
□ UI가 게임 상태를 정확히 반영
□ 성능이 목표 수준(30 FPS) 달성
□ 의존성 문제 없이 일정 준수
```

### **4-5주차 준비사항**
```
자원 시스템 연결 준비:
□ 생존자가 자원 오브젝트 인식 기반 ✓
□ 수집 명령(G키) 처리 AI 인터페이스 ✓
□ 인벤토리 시스템과 UI 연동 준비 ✓
□ 자원 표시 UI의 실제 데이터 바인딩 ✓

의존성 사전 해결:
□ 자원 오브젝트 클래스 기본 구조 미리 생성
□ 수집 상호작용 인터페이스 사전 설계
□ 다음 주차 작업 분배 및 의존성 체크
```