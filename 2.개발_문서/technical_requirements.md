# 기술적 요구사항

## 🎮 개발 환경 및 플랫폼

### 엔진 및 개발 도구
```
게임 엔진: Unreal Engine 5.6
- 이유: 최신 안정화 기능, 개선된 블루프린트 성능
- 라이선스: 로열티 기반 (매출 100만 달러 이후 5%)

개발 언어 (신입팀 고려):
- 블루프린트 (85%): 게임플레이 로직, UI, 이벤트 시스템
- C++ (15%): 꼭 필요한 성능 최적화만 (후순위)

IDE 및 도구:
- Visual Studio 2022 Community (무료, C++)
- Unreal Editor (블루프린트 위주 개발)
- Git + GitHub/GitLab (버전 관리, LFS 필수)
- Trello 또는 Discord (이슈 트래킹, 협업)
```

### 타겟 플랫폼
```
주 플랫폼: PC (Windows 10/11)
- 최소 사양: i5-8400, 8GB RAM, GTX 1060
- 권장 사양: i7-10700, 16GB RAM, RTX 3060
- 해상도: 1920x1080 ~ 3840x2160

추후 확장: 
- Steam Deck (Proton 호환성 고려)
- macOS (Metal API 활용)
- Xbox Series S/X (Game Pass 진출)
```

## 🏗️ 아키텍처 설계

### 전체 시스템 구조 (신입팀 친화적)
```
┌─ UI 레이어 (개발자 B) ───────────────────────────┐
│ MainMenu, HUD, Inventory, BuildMenu             │
├─ 게임플레이 레이어 (개발자 A) ───────────────────┤
│ PlayerController, GameMode, SurvivorManager     │
├─ 전투/AI 레이어 (개발자 C) ─────────────────────┤
│ Combat, AI, Wave, Enemy                         │
├─ 데이터 레이어 (공통) ──────────────────────────┤
│ DataTables, SaveGame, Configuration             │
└─ 언리얼 엔진 5.6 ──────────────────────────────┘

모듈 분리 원칙:
- 각자 담당 영역 명확히 구분
- Interface 통한 느슨한 결합
- 블루프린트 Function Library 활용
- 공통 컴포넌트는 팀 회의 후 결정
```

### 블루프린트 중심 컴포넌트 설계
```
Actor 기반 (블루프린트):
- BP_Survivor: 생존자 개체
- BP_Building_Base: 건물 베이스 클래스
  ├ BP_Barricade: 바리케이드
  ├ BP_WatchTower: 감시탑
  └ BP_Storage: 저장고
- BP_Enemy_Base: 적 베이스 클래스
- BP_Resource: 수집 가능한 자원

Component 시스템 (블루프린트):
- BPC_Stats: 능력치 및 상태 관리
- BPC_Inventory: 아이템 관리 (ActorComponent)
- BPC_Health: 체력 관리
- BPC_Task: 작업 관리
- BPC_AI: AI 행동 (신입자도 쉽게 수정 가능)

주의사항:
- C++ 컴포넌트는 최소화
- 블루프린트 인터페이스 적극 활용
- 상속보다는 컴포넌트 조합 우선
```

## 💾 데이터 관리 시스템

### 게임 데이터 구조 (신입팀 친화적)
```
DataTable 활용 (Excel → CSV → 언리얼):
- DT_Survivors: 생존자 기본 능력치
- DT_Buildings: 건물 정보 (비용, 시간, 효과)
- DT_Items: 아이템 정보
- DT_Waves: 웨이브별 적 구성
- DT_Events: 탐사 이벤트

구조체 설계 (블루프린트 Structure):
- S_SurvivorData: 생존자 정보
  ├ Name (String)
  ├ Stats (S_Stats 구조체)
  ├ Traits (Array of Enum)
  └ Equipment (Array of S_ItemData)

- S_BuildingData: 건물 정보
  ├ Name, Description (String)
  ├ Cost (S_ResourceCost)
  ├ BuildTime (Float)
  └ Effects (Array of S_Effect)

에셋 매니징:
- 폴더 구조 엄격 준수
- 네이밍 컨벤션 철저히 지키기
- Blueprint 카테고리 활용
- 주석 필수 작성
```

### 세이브/로드 시스템 (단순화)
```
SaveGame 클래스 (블루프린트):
- BP_GameSave: 메인 세이브 파일
  ├ CurrentDay (Integer)
  ├ Resources (S_ResourceData)
  ├ Survivors (Array of S_SurvivorSave)
  ├ Buildings (Array of S_BuildingSave)
  └ GameSettings (S_Settings)

저장 타이밍:
- 매 게임 내 1일 종료시 자동 저장
- 플레이어 수동 저장 (ESC 메뉴)
- 중요 이벤트 후 (웨이브 완료, 탐사 완료)
- 게임 종료시 자동 저장

구현 방식:
- 블루프린트 SaveGame 노드 활용
- JSON 형태 저장 (디버깅 편의)
- 슬롯 최대 5개
- 자동/수동 구분
```

## 🎨 렌더링 및 성능

### 탑뷰 렌더링 최적화
```
카메라 시스템:
- Orthographic 또는 고정 각도 Perspective
- 동적 LOD 시스템으로 거리별 디테일 조절
- Frustum Culling 최적화
- 화면 밖 객체 업데이트 최소화

레벨 스트리밍:
- 거점 중심 구역별 스트리밍
- 탐사 지역 비동기 로딩
- 메모리 사용량 모니터링

인스턴싱 활용:
- 동일 건물 Instanced Static Mesh
- 파티클 시스템 배칭
- UI 요소 배칭 최적화
```

### 메모리 관리
```
목표 메모리 사용량:
- 최소 사양: 6GB 이하
- 권장 사양: 8GB 이하
- 최대 사양: 12GB 이하

메모리 풀링:
- Object Pooling (적, 이펙트, 사운드)
- Texture Streaming 활용
- 가비지 컬렉션 최적화

프로파일링:
- Unreal Insights 활용
- 메모리 리크 감지
- CPU/GPU 병목 지점 분석
```

## 🤖 AI 및 게임플레이 시스템

### AI 시스템 설계 (신입팀용)
```
블루프린트 기반 AI:
- Behavior Tree (시각적 AI 로직)
- Blackboard (AI 데이터 저장소)
- AI Controller (블루프린트)

생존자 AI 상태:
- Idle: 대기 상태 (기본)
- Working: 작업 수행 중
- Moving: 이동 중
- Resting: 휴식 중
- Emergency: 긴급 상황 대응

AI 구현 난이도별 단계:
1단계 (쉬움): 기본 이동과 대기
2단계 (보통): 작업 수행과 휴식
3단계 (어려움): 긴급 상황 대응과 협력

몬스터 AI (단순화):
- 플레이어 추적
- 장애물 회피
- 공격 패턴 (3-4가지)
- 그룹 행동 (나중에 추가)
```

### 성능 최적화 (현실적 목표)
```
신입팀 최적화 우선순위:
1. 올바른 구현 (성능은 나중에)
2. 메모리 누수 방지
3. 무한 루프 방지
4. 적절한 Tick 사용

언리얼 5.6 활용:
- Lumen (동적 조명, 자동 최적화)
- Nanite (고품질 지오메트리, 자동 LOD)
- 내장 프로파일러 적극 활용

블루프린트 최적화:
- Event Tick 최소화
- Timer 함수 활용
- 불필요한 Cast 노드 제거
- 배열 연산 최적화

목표 성능 (현실적):
- 개발 중: 20-30 FPS (디버그 모드)
- 최종 빌드: 30-60 FPS
- 메모리: 4-6GB 사용
```

## 🌐 네트워킹 (향후 확장)

### 멀티플레이어 대비
```
아키텍처 준비:
- Client-Server 모델 기반 설계
- 상태 동기화 최소화
- 지연 보상 (Lag Compensation)
- 치트 방지 시스템

동기화 대상:
- 생존자 위치 및 상태
- 자원 및 건설 정보
- 웨이브 진행 상황
- 중요 이벤트
```

## 🔧 개발 도구 및 에디터

### 커스텀 에디터 도구
```
레벨 에디터 확장:
- 건설 시설 배치 도구
- 웨이브 시뮬레이션 도구
- 밸런스 테스트 도구
- 이벤트 트리거 시각화

데이터 관리 도구:
- CSV 임포트/익스포트
- 밸런스 시트 연동
- 로컬라이제이션 지원
- 빌드 자동화 스크립트
```

### 디버깅 시스템
```
인게임 디버그:
- AI 상태 시각화
- 경로 표시
- 성능 모니터링 오버레이
- 실시간 밸런스 조정

로깅 시스템:
- 게임플레이 이벤트 로깅
- 오류 자동 리포팅
- 플레이어 행동 분석
- 크래시 리포팅
```

## 📦 플러그인 및 서드파티

### 필수 에셋 및 도구 (신입팀 예산 고려)
```
무료 에셋 우선 활용:
- Epic Games 무료 월간 에셋
- 언리얼 마켓플레이스 무료 팩
- 퀴셀 브릿지 (3D 에셋)
- 믹사모 (캐릭터 애니메이션)

저예산 필수 구매:
- 폰트 팩 ($10-20)
- UI 아이콘 팩 ($15-30)
- 파티클 이펙트 팩 ($20-40)
- 사운드 이펙트 라이브러리 ($30-50)

자체 제작 vs 구매 기준:
- 개발 시간 > 3일 → 구매 고려
- 핵심 게임플레이 관련 → 자체 제작
- 일반적 요소 (UI, 이펙트) → 구매
- 학습 목적 요소 → 자체 제작
```

### 학습 리소스 및 교육
```
필수 학습 자료:
- Unreal Engine 5 공식 문서
- Epic Games YouTube 채널
- Unreal Engine 4/5 입문서 (한국어)
- 게임 개발 포트폴리오 만들기

주간 학습 계획:
- 월: 개인 기술 학습 (2시간)
- 화~목: 프로젝트 개발
- 금: 코드 리뷰 및 기술 공유
- 주말: 선택적 추가 학습

기술 공유 주제 예시:
- 블루프린트 최적화 팁
- 디버깅 기법
- Git 사용법
- 언리얼 프로파일러 사용법
```

### 개발 단계별 목표
```
1단계 (1-2개월): 기초 시스템
- 기본 탑뷰 카메라
- 생존자 이동 및 선택
- 간단한 UI
- Git 워크플로우 정착

2단계 (3-4개월): 핵심 기능
- 건설 시스템
- 기본 AI
- 자원 관리
- 세이브/로드

3단계 (5-6개월): 게임플레이 완성
- 웨이브 시스템
- 탐사 시스템
- 차원 소환
- 밸런싱

4단계 (7-8개월): 최적화 및 마무리
- 성능 최적화
- 버그 수정
- UI/UX 개선
- 출시 준비
```

## 🚀 성능 목표 및 최적화

### 프레임레이트 목표
```
타겟 FPS:
- 최소 사양: 30 FPS (1080p)
- 권장 사양: 60 FPS (1080p)
- 고사양: 60 FPS (4K)

최적화 전략:
- LOD 시스템 적극 활용
- 오클루젼 컬링 최적화
- 배칭 및 인스턴싱
- 텍스처 스트리밍
```

### 로딩 시간 목표
```
로딩 시간 기준:
- 게임 시작: 30초 이내
- 레벨 전환: 10초 이내
- 탐사 지역: 5초 이내
- 세이브/로드: 3초 이내

최적화 방법:
- 비동기 로딩 적극 활용
- 프리로딩 시스템
- 압축 및 스트리밍
- SSD 권장 사양
```

## 🔒 보안 및 안정성

### 치트 방지
```
클라이언트 보안:
- 중요 로직 서버 검증 (향후)
- 메모리 보호
- 패킷 암호화
- 시간 동기화 검증

안정성:
- 예외 처리 강화
- 자동 복구 시스템
- 안전한 세이브 시스템
- 메모리 누수 방지
```

## 📈 확장성 고려사항

### 모듈화 설계
```
시스템 분리:
- Core System (핵심 로직)
- UI System (인터페이스)
- Content System (게임 콘텐츠)
- Platform System (플랫폼별 기능)

DLC 대비:
- 플러그인 아키텍처
- 동적 콘텐츠 로딩
- 모드 지원 기반
- 데이터 확장성
```

### 현지화 준비
```
다국어 지원:
- Unreal Localization 시스템 활용
- 텍스트 분리 설계
- 폰트 동적 로딩
- 문화권별 UI 조정

지원 언어 계획:
- 1차: 한국어, 영어
- 2차: 일본어, 중국어 간체
- 3차: 독일어, 프랑스어, 스페인어
```

## 🧪 테스트 환경

### 자동화 테스트
```
Unit Test:
- 능력치 계산 로직
- 자원 관리 시스템
- AI 행동 검증
- 데이터 무결성

Integration Test:
- 시스템 간 상호작용
- 세이브/로드 무결성
- 성능 회귀 테스트
- 메모리 사용량 모니터링
```

### 플레이테스트 환경
```
내부 테스트:
- 개발자 테스트 빌드
- QA 전용 기능
- 디버그 모드 활성화
- 자동 리포팅 시스템

외부 테스트:
- 클로즈 베타 빌드
- 텔레메트리 수집
- 피드백 수집 시스템
- A/B 테스트 지원
```

## 📊 개발 일정 고려사항

### 기술적 리스크
```
고위험 요소:
- AI 시스템 복잡도
- 성능 최적화
- 멀티플레이어 구현 (향후)
- 플랫폼 호환성

완화 전략:
- 조기 프로토타이핑
- 점진적 최적화
- 전문가 자문
- 외부 도구 활용
```

### 기술 부채 관리
```
코드 품질:
- 코딩 표준 준수
- 정기적 리팩토링
- 문서화 의무화
- 코드 리뷰 시스템

아키텍처 관리:
- 정기적 아키텍처 검토
- 의존성 분석
- 성능 프로파일링
- 기술 스택 업데이트
```

## 🎯 우선순위 및 MVP

### MVP 기술 범위 (신입팀 현실적 목표)
```
1단계 MVP (2-3개월):
- 탑뷰 카메라 및 기본 조작
- 생존자 선택 및 이동
- 간단한 건설 (바리케이드, 저장고)
- 기본 자원 관리 (식량, 물)
- 간단한 웨이브 방어 (직선 이동 적)
- 메뉴 및 기본 UI

2단계 확장 (4-5개월):
- 고급 건설 시스템
- 생존자 AI (작업, 휴식)
- 능력치 시스템
- 탐사 기본 구조
- 세이브/로드

3단계 완성 (6-8개월):
- 차원 소환 시스템
- 복잡한 AI 행동
- 탐사 이벤트 시스템
- 밸런싱 및 최적화
- 출시 준비

보류/삭제 고려사항:
- 멀티플레이어 (너무 복잡)
- 모드 지원 (1인칭 개발에 집중)
- 고급 그래픽 효과 (성능 우선)
- 다중 플랫폼 (PC만 집중)
```

### 위험 요소 및 대응책
```
기술적 위험:
- 언리얼 엔진 학습 곡선 → 단계적 학습, 멘토링
- 복잡한 AI 시스템 → 단순한 상태 기계부터 시작
- 성능 최적화 → 나중 단계로 미루기
- Git 충돌 → 명확한 파일 분할, 정기 merge

관리적 위험:
- 일정 지연 → 기능 우선순위 명확화
- 팀원 역할 겹침 → 담당 영역 명확히 구분
- 의사소통 부족 → 일일 스탠드업, 주간 리뷰
- 기술 부채 누적 → 정기적 리팩토링 시간

완화 전략:
- 매주 플레이 가능한 빌드 유지
- 기능별 단계적 구현
- 외부 멘토링 활용
- 커뮤니티 질문 적극 활용
```